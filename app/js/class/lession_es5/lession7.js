/**
 *
 * 自由变量 到 作用域链
 *
 */

// 自由变量的定义:
{
  let x = 10
  function fn() {
    let b = 20
    console.log(x + b) // 30
    // fn作用域
  }
  fn()
  // 在Fn作用域之下使用变量 x，但没有在Fn作用域下声明该变量，则相对于Fn作用域下
  // x就是一个自由变量
}

// 误区: 有人说过要到父作用域中取，其实有时候这种解释会产生歧义
{
  let x = 10
  function bar() {
    console.log('全局作用于下创造的bar函数 ===>',x)
  }
  function fn(f) {
    let x = 30;
    (function() {
      f() // 此时bar调用 打印10 而不是 30,因为创建bar函数的作用域是在全局作用域
    })()
  }
  fn(bar)
}

// 多做一个例子
{
  let x = 10
  function fn() {
    let x = 30;
    function bar() {
      console.log('自由变量x ===>',x)
    }
    (function() {
      bar() // 此时bar调用时 打印的是 创建他的fn
    })()
  }
  fn()
}
// 总结: 自由变量具体的取值,需要到创建这个函数的作用域去取
// 注意: 是创建，而非调用,即静态作用域

/**
 * 关于作用域链
 *  总结: 取自由变量时的这个“作用域链”过程:(自由变量x)
 *   1.首先在当前作用域查找变量x,如果有则获取并结束，如果没有则继续
 *   2.如果当前作用域是全局作用域，则证明a尚未定义,结束，否则获取并结束
 *   3.（该变量不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域
 *   4.继续回到第一部
 */

// 上个例子，强化一下

{
  let a = 10
  function fn () {
    let b = 20
     function bar() {
       console.log('a,b ===>',a,b) // a ==> 10,b ===> 20
     }
     return bar
  }
  let x = fn(), // x ===> bar,仅返回了创建好的bar而未调用,但b的作用域已经确定
      b = 200
  x()
}